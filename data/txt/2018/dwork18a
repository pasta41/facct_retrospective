Decoupled Classifiers for Group-Fair and Efficient Machine Learning
Proceedings of Machine Learning Research 81:1‚Äì15, 2018 Conference on Fairness, Accountability, and Transparency
Cynthia Dwork dwork@seas.harvard.edu
Harvard University
Nicole Immorlica nicimm@microsoft.com
Microsoft Research New England
Adam Tauman Kalai adam.kalai@microsoft.com
Microsoft Research New England
Max Leiserson mdml@cs.umd.edu
University of Maryland
Editors: Sorelle A. Friedler and Christo Wilson
ABSTRACT
When it is ethical and legal to use a sen-
sitive attribute (such as gender or race) in
machine learning systems, the question re-
mains how to do so. We show that the
naÃàƒ±ve application of machine learning algo-
rithms using sensitive attributes leads to
an inherent tradeoff in accuracy between
groups. We provide a simple and efficient
decoupling technique, which can be added
on top of any black-box machine learning
algorithm, to learn different classifiers for
different groups. Transfer learning is used
to mitigate the problem of having too little
data on any one group.
1 INTRODUCTION
As algorithms are increasingly used to make de-
cisions of social consequence, the social values
encoded in these decision-making procedures are
the subject of increasing study, with fairness
being a chief concern (Pedreschi et al., 2008;
Zliobaite et al., 2011; Kamishima et al., 2011;
Dwork et al., 2011; Friedler et al., 2016; Angwin
et al., 2016; Chouldechova, 2017; Kleinberg et al.,
2016; Hardt et al., 2016; Joseph et al., 2016; Kus-
ner et al., 2017; Berk, 2009). Classification and
regression algorithms are one particular locus of
fairness concerns. Classifiers map individuals to
outcomes: applicants to accept/reject/waitlist;
adults to credit scores; web users to advertise-
ments; felons to estimated recidivism risk. In-
ùë•2
ùë•1
Figure 1: No linear classifiers can achieve greater
than 50% accuracy on both groups.
formally, the concern is whether individuals are
treated ‚Äúfairly,‚Äù however this is defined. Still
speaking informally, there are many sources of
unfairness, prominent among these being train-
ing the classifier on historically biased data and
a paucity of data for under-represented groups
leading to poor performance on these groups,
which in turn can lead to higher risk for those,
such as lenders, making decisions based on clas-
sification outcomes.
Should ML systems use sensitive attributes,
such as gender or race if available? The legal
and ethical factors behind such a decision vary
by time, country, jurisdiction, culture, and down-
stream application. Still speaking informally, it
is known that ‚Äúignoring‚Äù these attributes does
not ensure fairness, both because they may be
closely correlated with other features in the data
and because they provide context for understand-
c¬© 2018 C. Dwork, N. Immorlica, A.T. Kalai & M. Leiserson.
Decoupled Classifiers for Group-Fair and Efficient Machine Learning
ing the rest of the data, permitting a classifier
to incorporate information about cultural differ-
ences between groups (Dwork et al., 2011). Using
sensitive attributes may increase accuracy for all
groups and may avoid biases where a classifier
favors members of a minority group that meet
criteria optimized for a majority group, as illus-
trated visually in Figure 4 of 8.
In this paper, we consider how to use a sen-
sitive attribute such as gender or race to maxi-
mize fairness and accuracy, assuming that it is
legal and ethical. A data scientist wishing to fit,
say, a simple linear classifier, may use the raw
data, upweight/oversample data from minority
groups, or employ advanced approaches to fit-
ting linear classifiers that aim to be accurate and
fair. No matter what he does and what fairness
criteria he uses, assuming no linear classifier is
perfect, he may be faced with an inherent trade-
off between accuracy on one group and accuracy
on another. As an extreme illustrative example,
consider the two group setting illustrated in Fig-
ure 1, where feature x1 perfectly predicts the bi-
nary outcome y ‚àà {‚àí1, 1}. For people in group 1
(where x2 = 1), the majority group, y = sgn(x1),
i.e., y = 1 when x1 > 0 and ‚àí1 otherwise. How-
ever, for the minority group where x2 = 2, ex-
actly the opposite holds: y = ‚àísgn(x1). Now, if
one performed classification without the sensitive
attribute x2, the most accurate classifier predicts
y = sgn(x1), so the majority group would be per-
fectly classified and the minority group would be
classified as inaccurately as possible. However,
even using the group membership attribute x2,
it is impossible to simultaneously achieve better
than 50% (random) accuracy on both groups.
This is due to limitations of a linear classifier
sgn(w1x1 + w2x2 + b), since the same w1 is used
across groups.
In this paper we define and explore decoupled
classification systems, in which a separate1 classi-
fier is trained on each group. Training a classifier
involves minimizing a loss function that penal-
izes errors; examples include mean squared loss
and absolute loss. In decoupled classification sys-
1. In the case of linear classifiers, training separate clas-
sifiers is equivalent to adding interaction terms be-
tween the sensitive attributes and all other attributes.
More generally, the separate classifiers can equiva-
lently be thought of as a single classifier that branches
on the group attribute. The decoupling technique is a
simple way to add branching to any type of classifier.
tems one first obtains, for each group separately,
a collection of classifiers differing in the numbers
of positive classifications returned for the mem-
bers of the given group. Let this set of outputs
for group k be denoted Ck, k = 1, . . . ,K. The
output of the decoupled training step is an ele-
ment of C1 √ó . . .√óCK , that is, a single classifier
for each group. The output is chosen to minimize
a joint loss function that can penalize differences
in classification statistics between groups. Thus
the loss function can capture group fairness prop-
erties relating the treatment of different groups,
e.g., the false positive (respectively, false nega-
tive) rates are the same across groups; the de-
mographics of the group of individuals receiving
positive (negative) classification are the same as
the demographics of the underlying population;
the positive predictive value is the same across
groups.2 By pinning down a specific objective,
the modeler is forced to make explicit the tradeoff
between accuracy and fairness, since often both
cannot simultaneously be achieved. Finally, a
generalization argument relates fairness proper-
ties, captured by the joint loss on the training set,
to similar fairness properties on the distribution
from which the data were drawn. We broaden our
results so as to enable the use of transfer learning
to mitigate the problems of low data volume for
minority groups.
The following observation provides a property
essential for efficient decoupling. A profile is a
vector specifying, for each group, a number of
positively classified examples from the training
set. For a given profile (p1, . . . , pK), the most
accurate classifier also simultaneously minimizes
the false positives and false negatives. It is the
choice of profile that is determined by the joint
loss criterion. We show that, as long as the joint
loss function satisfies a weak form of monotonic-
ity, one can use off-the-shelf classifiers to find a
decoupled solution that minimizes joint loss.
The monotonicity requirement is that the joint
loss is non-decreasing in error rates, for any fixed
profile. This sheds some light on the thought-
provoking impossibility results of Chouldechova
(2017) and Kleinberg et al. (2016) on the impos-
sibility of simultaneously achieving three specific
2. In contrast individual fairness Dwork et al. (2011) re-
quires that similar people are treated similarly, which
requires a task-specific, culturally-aware, similarity
metric.
notions of group fairness (see Observation 1 in
Section 4.1).
Finally, we present experiments on 47 datasets
downloaded from http://openml.org. The ex-
periments are ‚Äúsemi-synthetic‚Äù in the sense that
the first binary feature was used as a substitute
sensitive feature since we did not have access to
sensitive features. We find that on many data
sets our algorithm improves performance while
much less often decreasing performance.
Remark. The question of whether or not to use
decoupled classifiers is orthogonal to our work,
which explores the mathematics of the approach,
and a comprehensive treatment of the pros and
cons is beyond our expertise. Most importantly,
we emphasize that decoupling, together with a
‚Äúpoor‚Äù choice of joint loss, could be used un-
fairly for discriminative purposes. Furthermore,
in some jurisdictions using a different classifica-
tion method, or even using different weights on
attributes for members of demographic groups
differing in a protected attribute, is illegal for
certain classification tasks, e.g. hiring. Even bar-
ring legal restrictions, the assumption that group
membership is an input bit is an oversimplifica-
tion, and in reality the information may be ob-
scured, and the definition of the groups may be
ambiguous at best. Logically pursuing the idea
behind the approach it is not clear which inter-
sectionalities to consider, or how far to subdi-
vide. Nonetheless, we believe decoupling is valu-
able and applicable in certain settings and thus
merits investigation.
The contributions of this work are: (a) show-
ing how, when using sensitive attributes, the
straightforward application of many machine
learning algorithms will face inherent tradeoffs
between accuracy across different groups, (b) in-
troducing an efficient decoupling procedure that
outputs separate classifiers for each class using
transfer learning, (c) modeling fair and accurate
learning as a problem of minimizing a joint loss
function, and (d) presenting experimental results
showing the applicability and potential benefit of
our approach.
1.1. Related Work
Group fairness has a variety of definitions, in-
cluding conditions of statistical parity, class bal-
ance and calibration. In contrast to individual
fairness, these conditions constrain, in various
ways, the dependence of the classifier on the sen-
sitive attributes. The statistical parity condition
requires that the assigned label of an individ-
ual is independent of sensitive attributes. The
condition formalizes the legal doctrine of dis-
parate impact imposed by the Supreme Court
in Griggs v Duke Power Company. Statistical
parity can be approximated by either modifying
the data set or by designing classifiers subject
to fairness regularizers that penalize violations
of statistical parity (see Feldman et al. (2015)
and references therein). Dwork et al. (2011) pro-
pose a ‚Äúfair affirmative action‚Äù methodology that
carefully relaxes between-group individual fair-
ness constraints in order to achieve group fair-
ness. Zemel et al. (2013) introduce a representa-
tional approach that attempts to ‚Äúforget‚Äù group
membership while maintaining enough informa-
tion to classify similar individuals similarly; this
approach also permits generalization to unseen
data points. To our knowledge, the earliest work
on trying to learn fair classifiers from histori-
cally biased data is by Pedreschi et al. (2008);
see also (Zliobaite et al., 2011) and (Kamishima
et al., 2011).
The class-balanced condition (called error-rate
balance by Chouldechova (2017) or equalized odds
by Hardt et al. (2016)), similar to statistical par-
ity, requires that the assigned label is indepen-
dent of sensitive attributes, but only conditional
on the true classification of the individual. For
binary classification tasks, a class-balanced clas-
sifier results in equal false positive and false neg-
ative rates across groups. One can also modify
a given classifier to be class-balanced while min-
imizing loss by adding label noise (Hardt et al.,
2016).
The well-calibrated condition requires that,
conditional on their label, an equal fraction of
individuals from each group have the same true
classification. A well-calibrated classifier labels
individuals from different groups with equal ac-
curacy. Hebert-Johnson et al. (2017) extend cal-
ibration to multi-calibration which requires the
classifier to be well calibrated on a collection of
sets of individuals, eg, all those described by cir-
cuits of a given size. The class-balanced solu-
tion (Hardt et al., 2016) also fails to be well-
calibrated. Chouldechova (2017) and Kleinberg
et al. (2016) independently showed that, except
in cases of perfect predictions or equal base rates
of true classifications across groups, there is no
class-balanced and well-calibrated classifier.
A number of recent works explore causal
approaches to defining and detecting
(un)fairness (Nabi and Shpitser, 2017; Kus-
ner et al., 2017; Bareinboim and Pearl, 2016;
Kilbertus et al., 2017). See the beautiful primer
of Pearl et al. (2016) for an introduction to the
central concepts and machinery.
Finally, we mention that sensitive attributes
are used in various real-world systems. As one
example, Hassidim et al. (2017) describe using
such features in an admissions matching system
for masters students in Israel.
2 PRELIMINARIES
Let X = X1 ‚à™ X2 ‚à™ . . . ‚à™ XK be the set of pos-
sible examples partitioned by group. The set of
possible labels is Y and the set of possible classifi-
cations is Z. A classifier is a function c : X ‚Üí Z.
We assume that there is a fixed family C of clas-
sifiers. For simplicity, we restrict our analysis the
case of binary classification Y = Z = {0, 1}, but
many of the results extended directly to regres-
sion or randomized classification Y,Z ‚äÜ R.
We suppose that there is a joint distribu-
tion D over labeled examples x, y ‚àà X √ó Y
and we have access to n training examples
(x1, y1), . . . , (xn, yn) ‚àà X √ó Y drawn indepen-
dently from D. We denote by g(x) the group
number to which x belongs and gi = g(xi), so
xi ‚àà Xgi .
Finally, as is common, we consider the loss
`D(c) = Ex,y‚àºD[`(y, c(x))] for an application-
specific loss function ` : Y √óZ ‚Üí R where `(y, z)
accounts for the cost of classifying as z an exam-
ple whose true label is y. The group-k loss for
D, c is defined to be `Dk(c) = ED[`(y, c(x))|x ‚àà
Xk] or 0 if D assigns 0 probability to Xk. The
standard approach in ML is to minimize `D(c)
over c ‚àà C. Common loss functions include the
L1 loss `(y, z) = |y ‚àí z| and L2 loss `(y, z) =
(y‚àí z)2. In Section 4, we provide a methodology
for incorporating a range of fairness notions into
loss.
3. Decoupling and the cost of
coupling
For a vector of K classifiers, c = (c1, c2, . . . , cK),
the decoupled classifier Œ≥c : X ‚Üí Z is defined to
be Œ≥c(x) = cg(x)(x). The set of decoupled clas-
sifiers is denoted Œ≥(C) = {Œ≥c | c ‚àà CK}. Some
classifiers, such as decision trees of unbounded
size over X = {0, 1}d, are already decoupled, i.e.,
Œ≥(C) = C. As we shall see, however, in high di-
mensions common families of classifiers in use are
coupled to avoid the curse of dimensionality.
The cost of coupling of a family C of classifiers
(with respect to `) is defined to be the worst-case
maximum of the difference between the loss of the
most accurate coupled and decoupled classifiers
over distributions D.
cost-of-coupling(C, `) =
max
D‚àà‚àÜ(X√óY)
[
min
c‚ààC
`D(c)‚àí min
Œ≥c‚ààŒ≥(C)
`D(Œ≥c)
]
.
Here ‚àÜ(S) denotes the set of probability dis-
tributions over set S. To circumvent measure-
theoretic nuisances, we require C,X ,Y to be fi-
nite sets. Note that numbers on digital com-
puters are all represented using a fixed-precision
(bounded number of bits) representation, and
hence all these sets may be assumed to be of finite
(but possibly exponentially large) size.
We now show that the cost of coupling is re-
lated to fairness across groups.
Lemma 1 Suppose cost-of-coupling(C, `) = /c.
Then there is a distribution D such that no mat-
ter which classifier c ‚àà C is used, there will al-
ways be a group k and a classifier c‚Ä≤ ‚àà C whose
group-k loss is at least /c smaller than that of c,
i.e., `Dk(c‚Ä≤) ‚â§ `Dk(c)‚àí /c.
Proof Let Œ≥c‚Ä≤ be a decoupled classifier with min-
imal loss where c‚Ä≤ = (c‚Ä≤1, . . . , c
‚Ä≤
K). This loss is a
weighted average (weighted by demography) of
the average loss on each group. Hence, for any c,
there must be some group k on which the loss of
c‚Ä≤k is /c less than that of c.
Hence, if the cost of coupling is positive, then the
learning algorithm that selects a classifier faces
an inherent tradeoff in accuracy across groups.
The following theorem shows that the cost of cou-
pling is large (a constant) for linear classifiers and
decision trees; similar arguments exist for other
common classifiers. All remaining proofs are de-
ferred to the full version.
Theorem 2 Fix X = {0, 1}d, Y = {0, 1}, and
K = 2 groups (encoded by the last bit of x). Then
the cost of coupling is at least 1/4 for:
1. Linear regression: Z = R, C = {w ¬∑ x +
b | w ‚àà Rd, b ‚àà R}, and `(y, z) = (y ‚àí z)2
2. Linear separators: Z = {0, 1}, C = {I[w ¬∑
x + b ‚â• 0] | w ‚àà Rd, b ‚àà R}, and `(y, z) =
|y ‚àí z|
3. Bounded-size decision trees: For Z =
{0, 1}, C being the set of binary decision trees
of size ‚â§ 2s leaves, and `(y, z) = |y ‚àí z|
We note that it is straightforward to extend the
above theorem to generalized linear models, i.e.,
functions c(x) = u(w ¬∑x) for monotonic functions
u : R ‚Üí R, which includes logistic regression
as one common special case. It is also possible,
though more complex, to provide a lower bound
on the cost of coupling of neural networks, regres-
sion forests, or other complex families of func-
tions of bounded representation size s. In order
to do so, one needs to simply show that the size-
s functions are sufficiently rich in that there are
two different size-s classifiers c = (c1, c2) such
that Œ≥c has 0 loss (say over the uniform distribu-
tion on X ) but that every single size-s classifier
has significant loss.
4. Joint loss and monotonicity
As discussed, the classifications output by an
ML classifier are often evaluated by their empir-
ical loss 1
n
‚àë
i `(yi, zi). To account for fairness,
we generalize loss to joint classifications across
groups. In particular, we consider an application-
specific joint loss LÃÇ : ([K] √ó Y √ó Z)‚àó ‚Üí R that
assigns a cost to a set of classifications, where
[K] = {1, 2, . . . ,K} indicates the group number
for each example. A joint loss might be, for pa-
rameter Œª ‚àà [0, 1]:
LÃÇ
(
„Äàgi, yi, zi„Äâni=1
)
=
Œª
n
n‚àë
i=1
|yi ‚àí zi|+
1‚àí Œª
n
K‚àë
k=1
‚à£‚à£‚à£‚à£‚à£‚à£
‚àë
i:gi=k
zi ‚àí
‚àë
i
zi
‚à£‚à£‚à£‚à£‚à£‚à£ .
The above LÃÇ trades off accuracy for differences in
number of positive classifications across groups.
For Œª = 1, this is simply L1 loss, while for Œª = 0,
the best classifications would have an equal num-
ber of positives in each group. Joint loss differs
from a standard ML loss function in two ways.
First, joint loss is aware of the sensitive group
membership. Second, it depends on the complete
labelings and is not simply a sum over labels.
Even with only K = 1 group, this captures
situations beyond what is representable by the
sum
‚àë
`(yi, zi). A simple example is when one
seeks exactly P positive examples:
LÃÇ
(
„Äàgi, yi, zi„Äâni=1
)
=
{
‚àë
|yi ‚àí zi| if
‚àë
zi = P
1 otherwise.
Since 1
n
‚àë
|yi‚àízi| ‚â§ 1, the 1 ensures that the loss
minimizer will have exactly P positives, if such a
classifier exists in C for the data.
In this section, we denote joint loss LÃÇ with the
hat notation indicating that it is an empirical ap-
proximation. In the next section we will define
joint loss L for distributions. We denote classifi-
cations by zi rather than the standard notation
yÃÇi which suggests predictions, because, as in the
above loss, one may choose classifications z 6= y
even with perfect knowledge of the true labels.
For the remainder of our analysis, we hence-
forth consider binary labels and classifications,
Y = Z = {0, 1}. Our approach is general, how-
ever, and our experiments include regression. For
a given „Äàxi, yi, zi„Äâni=1, and for any group k ‚â§ K
and all (y, z) ‚àà {0, 1}2, recall that the groups are
gi = g(xi) and define:
counts: nk =
‚à£‚à£{i | gi = k}
‚à£‚à£ ‚àà {1, 2, . . . , n}
profile: pÃÇk =
‚àë
i:gi=k
zi ‚àà [0, nk/n]
group losses: ÀÜÃÄ
k =
‚àë
i:gi=k
|zi ‚àí yi| ‚àà [0, 1]
Note that the normalization is such that the stan-
dard 0-1 loss is
‚àë
k
nk
n
ÀÜÃÄ
k and the fraction of pos-
itives within any class is n
nk
pÃÇk.
We note many studied fairness notions, includ-
ing numerical parity, demographic parity, and
false-negative-rate parity can be represented in
a joint loss function. For example, demographic
parity is:
ŒªLÃÇ1 + (1‚àí Œª)
‚àë
k
‚à£‚à£‚à£‚à£‚à£pÃÇk nnk ‚àí 1
K
‚àë
k‚Ä≤
pÃÇk‚Ä≤
n
nk‚Ä≤
‚à£‚à£‚à£‚à£‚à£ .
In many applications there is a different cost
for false positives where (y, z) = (0, 1) and false
negatives where (y, z) = (1, 0). The fractions of
false positives and negatives are defined, below,
for each group k. They can be computed based
on the fraction of positive labels in each group
œÄk:
œÄk =
‚àë
i:gi=k
yi
FPk =
‚àë
i:gi=k
zi(1‚àí yi) =
ÀÜÃÄ
k + pÃÇk
n
nk
‚àí œÄk
FNk =
‚àë
i:gi=k
(1‚àí zi)yi =
ÀÜÃÄ
k + œÄk ‚àí pÃÇk n
nk
(2)
While minimizing group loss ÀÜÃÄ
k = FPk + FNk in
general does not minimize false positives or false
negatives on their own, the above implies that for
a fixed profile pÃÇk, the most accurate classifier on
group k simultaneously minimizes false positives
and false negatives. The above can be derived by
adding or subtracting the equations ÀÜÃÄ
k = FPk +
FNk (since every error is a false positive or a
false negative) and n
nk
pÃÇk = FPk + (œÄk ‚àí FNk)
(since every positive classification is either a false
positive or true positive, and the fraction of true
positives from group k are œÄk ‚àí FNk). We also
define the false negative rate FNRk = FNk/œÄk.
False positive rates can be defined similarly.
Equations (1) and (2) imply that, if one de-
sires fewer false positives and false negatives (all
other things being fixed), then greater accuracy
is better. That is, for a fixed profile, the most
accurate classifier simultaneously minimizes false
positives and false negatives. This motivates the
following monotonicity notion.
Definition 3 (Monotinicity) Joint loss LÃÇ is
monotonic if, for any fixed „Äàgi, yi„Äâni=1 ‚àà ([K] √ó
Y)‚àó, LÃÇ can be written as c(„ÄàÀÜÃÄk, pÃÇk„ÄâKk=1) where c :
[0, 1]2K ‚Üí R is a function that is nondecreasing
in each ÀÜÃÄ
k fixing all other inputs to c.
That is, for a fixed profile, increasing ÀÜÃÄ
k can only
increase joint loss. To give further intuition be-
hind monotonicity, we give two other equivalent
definitions.
Definition 4 (Monotonicity) Joint loss LÃÇ is
monotonic if, for any „Äàgi, yi, zi„Äâni=1 ‚àà ([K]√óY √ó
Z)‚àó, and any i, j where gi = gj, yi ‚â§ yj and
zi ‚â§ zj: swapping zi and zj can only increase
loss, i.e.,
LÃÇ(„Äàgi, yi, zi„Äâni=1) ‚â§ LÃÇ(„Äàgi, yi, z‚Ä≤i„Äâni=1),
where z‚Ä≤ is the same as z except z‚Ä≤i = zj and
z‚Ä≤j = zi.
We can see that if yi = yj then swapping zi and zj
does not change the loss (because the condition
can be used in either order). This means that
the loss is ‚Äúsemi-anonymous‚Äù in the sense that
it only depends on the numbers of true and false
positives and negatives for each group. The more
interesting case is when (yi, yj) = (0, 1) where
it states that the loss when (zi, zj) = (0, 1) is
no greater than the loss when (zi, zj) = (1, 0).
Finally, monotonicity can also be defined in terms
of false positives and false negatives.
Definition 5 (Monotonicity) Joint loss LÃÇ is
monotonic if, for any „Äàgi, yi, zi„Äâni=1 ‚àà ([K]√óY √ó
Z)‚àó, and any alternative classifications z‚Ä≤1, . . . , z
‚Ä≤
n
such that, in each group k, the same profile as z
but all smaller or equal false positive rates and
all smaller or equal false negative rates, the loss
of classifications z‚Ä≤i is no greater than that of zi.
Lemma 6 Definitions 3, 4, and 5 of Mono-
tonicity are equivalent.
One may be tempted to consider a simpler no-
tion of monotonicity, such as requiring the loss
with zi = yi to be no greater than that of
zi = 1 ‚àí yi, fixing everything else. However,
this would rule out many natural monotonic joint
losses LÃÇ, such as demographic parity.
4.1. Discussion: fairness metrics versus
objectives
The monotonicity requirement admits a range of
different fairness criteria, but not all. We do not
mean to imply that monotonicity is necessary for
fairness, but rather to discuss the implications of
minimizing a non-monotonic loss objective. The
following example helps illustrate the boundary
between monotonic and non-monotonic.
Observation 1 Fix K = 2. The following joint
loss is monotonic if and only if Œª ‚â§ 1/2:
(1‚àí Œª)(ÀÜÃÄ
1 + ÀÜÃÄ
2) + Œª|ÀÜÃÄ1 ‚àí ÀÜÃÄ
2|.
The loss in the above lemma trades off accuracy
for differences in loss rates between groups. What
we see is that monotonic losses can account, to
a limited extent, for differences across groups in
fractions of errors, and related statements can be
made for combinations of rates of false positive
and false negative, inspired by ‚Äúequal odds‚Äù def-
initions of fairness. However, when the weight Œª
on the fairness term exceeds 1/2, then the loss
is non-monotonic and one encounters situations
where one group is punished with lower accuracy
in the name of fairness. This may still be desir-
able in a context where equal odds is a primary
requirement, and one would rather have random
classifications (e.g., a lottery) than introduce any
inequity.
What is the goal of an objective function? We
argue that a good objective function is one whose
optimization leads to favorable outcomes, and
should not be confused with a fairness metric
whose goal is quantify unfairness. Often, a differ-
ent function is appropriate for quantifying unfair-
ness than for optimizing it. For example, the dif-
ference in classroom performance across groups
may serve as a good metric of unfairness, but it
may not be a good objective on its own. The root
cause of the unfairness may have begun long be-
fore the class. Now, suppose that the objective
from the above observation was used by a teacher
to design a semester-long curriculum with the
best intention of increasing the minority group‚Äôs
performance to the level of the majority. If there
is no curriculum that in one semester increases
one group‚Äôs performance to the level of another
group‚Äôs performance, then optimizing the above
loss for Œª > 1/2 leads to an undesirable outcome:
the curriculum would be chosen so as to inten-
tionally misteach students the higher-performing
group of students so that their loss increases to
match that of the other group. This can be see
by rewriting the loss as follows:
(1‚àí Œª)(ÀÜÃÄ
1 + ÀÜÃÄ
2) + Œª|ÀÜÃÄ1 ‚àí ÀÜÃÄ
2|
= 2Œªmax{ÀÜÃÄ1, ÀÜÃÄ
2}+ (1‚àí 2Œª)(ÀÜÃÄ
1 + ÀÜÃÄ
2).
This rewriting illuminates why Œª ‚â§ 1/2 is neces-
sary for monotonicity, otherwise there is a nega-
tive weight on the total loss. Œª = 1/2 corresponds
to maximizing the minimum performance across
groups while Œª = 0 means teaching to the aver-
age, and Œª in between allows interpolation. How-
ever, putting too much weight on fairness leads
to undesirable punishing behavior.
5. Minimizing joint loss on training
data
Here, we show how to use learning algorithm to
find a decoupled classifier in Œ≥(C) that is opti-
mal on the training data. In the next section, we
show how to generalize this to imperfect random-
ized classifiers that generalize to examples drawn
from the same distribution, potentially using an
arbitrary transfer learning algorithm.
Our approach to decoupling uses a learning
algorithm for C as a black box. A C-learning
algorithm A : (X √ó Y)‚àó ‚Üí 2C returns one or
more classifiers from C with differing numbers
of positive classifications on the training data,
i.e., for any two distinct c, c‚Ä≤ ‚àà A
(
„Äàxi, yi„Äâni=1),‚àë
i c(xi) 6=
‚àë
i c
‚Ä≤(xi). In ML, it is common
to simultaneously output classifiers with varying
number of positive classifications, e.g., in com-
puting ROC or precision-recall curves (Davis and
Goadrich, 2006). Also note that a classifier that
purely minimizes errors can be massaged into one
that outputs different fractions of positive and
negative examples by reweighting (or subsam-
pling) the positive- and negative-labeled exam-
ples with different weights.
Our analysis will be based on the assumption
that the classifier is in some sense optimal, but
importantly note that it makes sense to apply the
reduction to any off-the-shelf learner. Formally,
we say A is optimal if for every achievable num-
ber of positives P ‚àà
{‚àë
i c(xi)
‚à£‚à£ c ‚àà C}, it out-
puts exactly one classifier that classifies exactly
P positives, and this classifier has minimal er-
ror among all classifiers which classify exactly P
positives. Theorem 7 shows that an optimal clas-
sifier can be used to minimize any (monotonic)
joint loss
Theorem 7 For any monotonic joint loss func-
tion LÃÇ, any C, and any optimal learner A for C,
Algorithm 1: Decouple (A, LÃÇ, {„Äàxi, yi„Äâ}, {Xi})
Minimize training loss LÃÇ using learner A
1. For k = 1 to K, Ck ‚Üê A
(
„Äàxi, yi„Äâi:xi‚ààXk
)
. Learner outputs a set of classifiers.
2. return Œ≥c that minimizes
minc‚ààC1√ó...√óCK
LÃÇ
(
„Äàgi, yi, Œ≥c(xi)„Äâni=1
)
. Œ≥c(xi) = cgi(x))
The simple decoupling algorithm partitions data
by group and runs the learner on each group.
Within each group, the learner outputs one or
more classifiers of differing numbers of positives.
the Decouple procedure from Algorithm 1 re-
turns a classifier in Œ≥(C) of minimal joint loss
LÃÇ. For constant K, Decouple runs in time lin-
ear in the time to run A and polynomial in the
number of examples n and time to evaluate LÃÇ and
classifiers c ‚àà C.
Implementation notes. Note that if the pro-
file is fixed, as in LÃÇp‚àó , then one can simply run
the learning algorithm once for each group, tar-
geted at p‚àók positives in each group. Otherwise,
also note that to perform the slowest step which
involves searching over O(nK) losses of combina-
tions of classifiers, one can pre-compute the error
rates and profiles of each classifier. In the ‚Äúbig
data‚Äù regime of very large n, the O(nK) evalua-
tions of a simple numeric function of profile and
losses will not be the rate limiting step.
6. Generalization and transfer
learning
We now turn to the more general randomized
classifier model in which Z = [0, 1] but still with
Y = {0, 1}, and we also consider generalization
loss as opposed to simply training loss. We will
define loss in terms of the underlying joint dis-
tribution D over X √ó Y from which training ex-
amples are drawn independently. We define the
true error, true profile, and true probability:
ŒΩk = Pr[x ‚àà Xk] = E[nk/n]
pk = E
[
zI[x ‚àà Xk]
]
= E[pÃÇk]
`k = E
[
|y ‚àí z| | x ‚àà Xk
]
= E[ÀÜÃÄk|nk > 0]
Joint loss L is defined on the joint distribution
¬µ on g, y, z ‚àà [K] √ó Y √ó Z induced by D and
a classifier c : X ‚Üí Z. A distributional joint
loss L is related to empirical joint loss LÃÇ in that
L = limn‚Üí‚àû E[LÃÇ], i.e., the limit of the empirical
joint loss as the number of training data grows
without bound (if it exists).
Fixing the marginal distribution over [K]√óY,
joint loss L : [0, 1]2K ‚Üí R can be viewed as
a function of `1, p1, . . . , `K , pK (in addition to
group probabilities Pr[g(x) = k] which are in-
dependent of the classification). In addition to
requiring monotonicity, namely L being nonde-
creasing in `k fixing all other parameters, we will
assume that L is continuous with a bound on the
rate of change of the form:
|L(`1, p1, . . . , `K , pK)‚àí L(`‚Ä≤1, p
‚Ä≤
1, . . . , `
‚Ä≤
K , p
‚Ä≤
K)| ‚â§
R
‚àë
k
(
ŒΩk|`k ‚àí `‚Ä≤k|+ |pk ‚àí p‚Ä≤k|
)
, (3)
for parameter R ‚â• 0 and all `k, `
‚Ä≤
k, pk, p
‚Ä≤
k ‚àà [0, 1].
Note that the ŒΩk in the above bound is neces-
sary for our analysis because a loss that depends
on `k without ŒΩk may require exponentially large
quantities of data to estimate and optimize over
if ŒΩk is exponentially small. Of course, alterna-
tively ŒΩk could be removed from this assumption
by imposing a lower bound on all ŒΩk.
Many losses, such as L1 and LNPŒª above, can
be shown to satisfy this continuity requirement
for R = 1 and R = 2, respectively. We also note
that the reduction we present can be modified
to address certain discontinuous loss functions.
For instance, for a given target allocation (i.e., a
fixed fraction of positive classifications for each
group), one simply finds the classifier of minimal
empirical error for each group which achieves the
desired fraction of positives as closely as possible.
A transfer learning algorithm for C is A :
(X √ó{0, 1})‚àó√ó(X √ó{0, 1})‚àó ‚Üí 2C , where A takes
in-group examples „Äàxi, yi„Äâni=1 and out-group ex-
amples „Äàx‚Ä≤i, y‚Ä≤i„Äân
‚Ä≤
i=1, both from X √ó {0, 1}. This is
also called supervised domain adaptation. The
distribution of out-group examples is different
from (but related to) the distribution of in-group
samples. The motivation for using the out-group
examples is that if one is trying to learn a classi-
fier on a small dataset, accuracy may be increased
using related data.
Algorithm 2: G.D. (T, LÃÇ, {„Äàxi, yi„Äâ}, {Xi})
1. For k = 1 to K,
‚Ä¢ nk ‚Üê |{i ‚â§ n | xi ‚àà Xk}|
‚Ä¢ Ck ‚Üê T
(
„Äàxi, yi„Äâi:xi‚ààXk
, „Äàxi, yi„Äâi:xi 6‚ààXk
)
. Run transfer learner, output is a set
2. For all c ‚àà Ck,
‚Ä¢ pÃÇk[c]‚Üê 1
n
‚àë
i:xi‚ààXk
c(xi)
. Estimate profile
‚Ä¢ ÀÜÃÄ
k[c]‚Üê 1
nk
‚àë
i:xi‚ààXk
|yi ‚àí c(xi)|
. Estimate error rates
3. return Œ≥c for c ‚àà
arg minC1√ó...√óCK
LÃÇ
(
„ÄàÀÜÃÄi[ci], pÃÇi[ci]„ÄâKi=1
)
The general decoupling algorithm uses a transfer
learning algorithm T .
In the next section, we describe and analyze
a simple transfer learning algorithm that down-
weights samples from the out-group. For that
algorithm, we show:
Theorem 8 Suppose that, for any two groups
j, k ‚â§ K and any classifiers c, c‚Ä≤ ‚àà C,
|(`j(c)‚àí `j(c‚Ä≤))‚àí (`k(c)‚àí `k(c‚Ä≤))| ‚â§ ‚àÜ (4)
For algorithm 2 with the transfer learning algo-
rithm described in Section 6.1, with probability
‚â• 1 ‚àí Œ¥ over the n iid training data, the algo-
rithm outputs cÃÇ with L(cÃÇ) at most
min
c‚ààC
L(c) + 5RKœÑ +R
‚àë
k
min
(
œÑ
‚àö
,‚àÜ
)
,
where œÑ =
‚àö
K, the run-time of the algorithm is polynomial
in n and the runtime of the optimizer over C.
The assumption in (4) states that the perfor-
mance difference between classifiers is similar
across different groups and is weaker than an as-
sumption of similar classifier performance across
groups. Note that it would follow from a simpler
but stronger requirement that |`j(c) ‚àí `k(c)| ‚â§
‚àÜ/2 by the triangle inequality.
Parameter settings (see Lemma 10) and tighter
bounds can be found in the next section. How-
ever, we can still see qualitatively that, as n
grows, the bound decreases roughly like O(n‚àí1/2)
as expected. We also note that for groups with
large ŒΩk, as we will see in the next section, the
transfer learning algorithm places weight 0 on
(and hences ignores) the out-group data. For
small3 ŒΩk, the algorithm will place significant
weight on the out-group data.
6.1. A transfer learning algorithm T
In this section, we describe analyze a simple
transfer learning algorithm that down-weights4
out-group examples by parameter Œ∏ ‚àà [0, 1]. To
choose Œ∏, we can either use cross-validation on
an independent held-out set, or Œ∏ can be chosen
to minimize a bound as we now describe. The
cross-validation, which we do in our experiments,
is appropriate when one does not have bounds at
hand on the size of set of classifiers or the differ-
ence between groups, as we shall assume, or when
one simply has a black-box learner that does not
perfectly optimize over C. We now proceed to
derive a bound on the error that will yield a pa-
rameter choice Œ∏.
Consider k to be fixed. For convenience, we
write n‚àík = n‚àínk as the number of samples from
other groups. Define ÀÜÃÄ‚àík and `‚àík analogously to
ÀÜÃÄ
k and `k for out-of-group data xi 6‚àà Xk.
Instead of outputting a set of classifiers, one for
each different number of positives within group
k, it will be simpler to think of the group-k pro-
file pÃÇk = P as being specified in advance, and we
hence focus our attention on the subset of classi-
fiers,
CkP =
{
c ‚àà C
‚à£‚à£‚à£‚à£ 1
n
‚àë
i:xi‚ààXk
c(xi) = P
}
,
which depends on the training data. The bounds
in this section will be uninteresting, of course,
when CkP is empty (e.g., in the unlikely event
3. For very small ŒΩk < œÑ , the term ŒΩk ‚àí œÑ is negative
(making the left side of the above min imaginary), in
which case we define the min to be the real term on
the right.
4. If the learning algorithm doesn‚Äôt support weighting,
subsampling can be used instead.
that x1 = x2 = . . . = xn, the only realizable pÃÇk
of interest are 0 and 1). The general algorithm
will simply run the subroutine described in this
section nk+1 ‚â§ n+1 times, once for each possible
value of pÃÇk.5 Of course, |CkP | ‚â§ |C|.
As before, we will assume that the underlying
learner is optimal, meaning that given a weighted
set of examples (w1, x1, y1), . . . , (wn, xn, yn) with
total weight W =
‚àë
wi, it returns a classifier c ‚àà
CkP that has minimal weighted error
‚àë wi
W |yi ‚àí
c(xi)| among all classifiers in CkP .
In Appendix A, we derive a closed-form solu-
tion for Œ∏, the (approximately) optimal down-
weighting of out-group data for our transfer
learning algorithm. This solution depends on
a bound on the difference in classifier ranking
across different groups. For small ‚àÜ, the dif-
ference in error rates of each pair of classifiers
is approximately the same for in-group and out-
group data. In this case, we expect generalization
to work well and hence Œ∏ ‚âà 1. For large ‚àÜ, out-
group data doesn‚Äôt provide much guidance for the
optimal in-group classifier, and we expect Œ∏ ‚âà 0.
For a fixed k and Œ∏ ‚àà [0, 1], let cÃÇ be a classifier
that minimizes the empirical loss when out-of-
group samples are down-weighted by Œ∏, i.e.,
cÃÇ ‚àà arg min
c‚ààCkP
nk ÀÜÃÄ
k(c) + Œ∏n‚àík ÀÜÃÄ‚àík(c),
and c‚àó be an optimal classifier that minimizes the
true loss, i.e.,
c‚àó ‚àà arg min
c‚ààCkP
`k(c).
We would like to choose Œ∏ such that `k(cÃÇ) is
close to `k(c‚àó). In order to derive a closed-form
solution for Œ∏ in terms of ‚àÜ, we use concentration
bounds to bound the expected error rates of cÃÇ
and c‚àó in terms of ‚àÜ and Œ∏, and then choose Œ∏ to
minimize this expression.
We find that, as long as nk <
Œ¥ the
optimal choice of Œ∏ will be strictly in between 0
and 1.
7. Experiment
For this experiment, we used data that is ‚Äúsemi-
synthetic‚Äù in that the 47 datasets are ‚Äúreal‚Äù
5. In practice, classification learning algorithms gener-
ally learn a single real-valued score and consider dif-
ferent score thresholds.
0.2 0.4 0.6 0.8 1.0
decoupled loss/blind loss
0.5
0.6
0.7
0.8
0.9
1.0
co
u
p
le
d
 l
o
ss
/b
lin
d
 l
o
ss
Comparison of joint loss across datasets
Figure 2: Comparing the joint loss of our de-
coupled algorithm with the coupled
and blind baselines. Each point is a
dataset. A ratio less than 1 means
that the loss was smaller for the de-
coupled or coupled algorithm than the
blind baseline, i.e, that using the sensi-
tive feature resulted in decreased error.
Points above the diagonal represent
datasets in which the decoupled algo-
rithm outperformed the coupled one.
(downloaded from openml.org) but an arbitrary
binary attribute was used to represent a sensi-
tive attribute, so K = 2. The base classifier was
chosen to be least-squares linear regression for
its simplicity (no parameters), speed, and repro-
ducibility.
In particular, each dataset was a univari-
ate regression problem with balanced loss for
squared error, i.e., LÃÇB = 1
2 (ÀÜÃÄ
1 + ÀÜÃÄ
2) where ÀÜÃÄ
k =‚àë
i:gi=k
(yi‚àí zi)2/nk. To gather the datasets, we
first selected the problems with twenty or fewer
dimensions. Classification problems were con-
verted to regression problems by assigning y = 1
to the most common class and y = 0 to all other
classes. Regression problems were normalized so
that y ‚àà [0, 1]. Categorical attributes were simi-
larly converted to binary features by assigning 1
to the most frequent category and 0 to others.
The sensitive attribute was chosen to be the
first binary feature such that there were at least
100 examples in both groups (both 0 and 1 val-
ues). Further, large datasets were truncated so
that there were at most 10,000 examples in each
group. If there was no appropriate sensitive at-
0.2 0.4 0.6 0.8 1.0
decoupled loss/blind loss
0.2
0.4
0.6
0.8
1.0
1.2
d
e
co
u
p
le
d
 l
o
ss
/b
lin
d
 l
o
ss
 (
w
it
h
o
u
t 
tr
a
n
sf
e
r)
Comparison of joint loss across datasets
Figure 3: Comparing the joint loss of our de-
coupled algorithm with the decoupled
algorithm with and without transfer
learning. Each point is a dataset. A
ratio less than 1 means that the loss
was smaller for the decoupled algo-
rithm than the blind baseline. Points
above the diagonal represent datasets
in which transfer learning improved
performance compared to decoupling
without transfer learning.
tribute, then the dataset was discarded. We also
discarded a small number of ‚Äútrivial‚Äù datasets
in which the data could be perfectly classified
(less than 0.001 error) with linear regression. The
openml id‚Äôs and detailed error rates of the 45 re-
maining datasets are listed in the appendix.
All experiments were done with five-fold cross-
validation to provide an unbiased estimate of gen-
eralization error on each dataset. Algorithm 2
was implemented, where we further used five-fold
cross validation (within each of the outer folds)
to choose the best down-weighting parameter
Œ∏ ‚àà {0, 2‚àí10, 2‚àí9, . . . , 1} for each group. Hence,
least-squares regression was run 5 ‚àó 5 ‚àó 11 = 275
times on each dataset to implement our algo-
rithm.
The baselines were considered: the blind base-
line is least-squares linear regression that has no
access to the sensitive attribute, the coupled base-
line is least-squares linear regression that can
take into account the sensitive attribute.
Figure 2 compares the loss of the coupled base-
line (x-axis) and our decoupled algorithm (y-
axis) to that of the blind baseline. In particular,
the log ratio of the squared errors is plotted, as
this quantity is immune to scaling of the y val-
ues. Each point is a dataset. Points to the left of
1 (x < 1) represent datasets where the coupled
classifier outperformed the blind one. Points be-
low the horizontal line y < 1 represent points
in which the decoupled algorithm outperformed
the indiscriminate baseline. Finally, points above
the diagonal line x = y represent datasets where
the decoupled classifier outperformed the coupled
classifier.
Figure 3 compares transfer learning to decou-
pling without any transfer learning (i.e., just
learning on the in-group data or setting Œ∏ = 0).
As one can see, on a number of datasets, transfer
learning significantly improves performance. In
fact, without transfer learning the coupled clas-
sifiers significantly outperform decoupled classi-
fiers on a number datasets.
8. Image retrieval experiment
In this section, we describe an anecdotal example
that illustrates the type of effect the theory pre-
dicts, where a classifier biases towards minority
data that which is typical of the majority group.
We hypothesized that standard image classifiers
for two groups of images would display bias to-
wards the majority group, and that a decoupled
classifier could reduce this bias. More specifically,
consider the case where we have a setX = X1‚à™X2
of images, and want to learn a binary classifier
c : X ‚Üí {0, 1}. We hypothesized that a coupled
classifier would display a specific form of bias we
call majority feature bias, such that images in the
minority group would rank higher if they had fea-
tures of images in the majority group.
We tested this hypothesis by training classifiers
to label images as ‚Äúsuit‚Äù or ‚Äúno suit‚Äù. We con-
structed an image dataset by downloading the
‚Äúsuit, suit of clothes‚Äù synset as a set of posi-
tives, and ‚Äúmale person‚Äù and ‚Äúfemale person‚Äù
synsets as the negatives, from ImageNet Deng
et al. (2009). We manually removed images in the
negatives that included suits or were otherwise
outliers, and manually classified suits as ‚Äúmale‚Äù
or ‚Äúfemale‚Äù, removing suit images that were nei-
ther. We used the pre-trained BVLC CaffeNet
model ‚Äì which is similar to the AlexNet mode
from Krizhevsky et al. (2012) ‚Äì to generate fea-
tures for the images and clean the dataset. We
Linear
classifier
Decoupled 
linear
classifiers
Figure 4: Differences between image classifica-
tions of ‚Äúsuit‚Äù using standard lin-
ear classifiers and decoupled classifiers
(trained using standard neural network
image features). The females selected
by the linear classifier are wearing a
tuxedo and blazer more typical of the
majority male group.
used the last fully connected of layer (‚Äúfc7‚Äù) of
the CaffeNet model as features, and removed im-
ages where the most likely label according to the
CaffeNet model was ‚Äúenvelope‚Äù (indicating that
the image was missing), or ‚Äúsuit, suit of clothes‚Äù
or ‚Äúbow tie, bow-tie, bowtie‚Äù from the negatives.
The dataset included 506 suit images (462 male,
44 female) and 1295 no suit images (633 male,
662 female).
We then trained a coupled and decoupled stan-
dard linear support vector classifier (SVC) on this
dataset, and provide anecdotal evidence that the
decoupled classifier displays less majority feature
bias than the coupled classifier. We trained the
coupled SVC on all images, and then ranked im-
ages according to the predicted class. We trained
decoupled SVCs, with one SVC trained on the
male positives and all negatives, and the other
on female positives and all negatives. Both clas-
sifiers agreed on eight of the top ten ‚Äúfemales‚Äù
predicted as ‚Äúsuit‚Äù, and Fig. 4 shows the four im-
ages (two per classifier) that differed. One of the
images found by the coupled classifier is a woman
in a tuxedo (typically worn by men), which may
be an indication of majority feature bias; adding
a binary gender attribute to the coupled classifier
did not change the top ten predictions for ‚Äúfemale
suit.‚Äù We further note that we also tested both
the coupled and decoupled classifier on out-of-
sample predictions using 5-fold cross-validation,
and that both were highly accurate (both had
94.5% accuracy, with the coupled classifier pre-
dicting one additional true positive).
We emphasize that we present this experiment
to provide an anecdotal example of the potential
advantages of a decoupled classifier, and we do
not make any claims on generalizability or effect
size on this or other real world datasets because
of the small sample size and the several manual
decisions we made.
9. Conclusions
In this paper, we give a simple technical approach
for a practitioner using ML to incorporate sensi-
tive attributes. Our approach avoids unneces-
sary accuracy tradeoffs between groups and can
accommodate an application-specific objective,
generalizing the standard ML notion of loss. For
a certain family of ‚Äúweakly monotonic‚Äù fairness
objectives, we give a black-box reduction that can
use any off-the-shelf classifier to efficiently opti-
mize the objective. In contrast to much prior
work on ML which first requires complete fair-
ness, this work requires the application designer
to pin down a specific loss function that trades
off accuracy for fairness.
Experiments demonstrate that decoupling can
reduce the loss on some datasets for some poten-
tially sensitive features.
References**

Julia Angwin, Jeff Larson, Surya Mattu, and
Lauren Kirchner. Machine bias: Theres soft-
ware used across the country to predict future
criminals. and its biased against blacks. ProP-
ublica, May, 23, 2016.**

Elias Bareinboim and Judea Pearl. Causal infer-
ence and the data-fusion problem. Proceedings
of the National Academy of Sciences, 113(27):
7345‚Äì7352, 2016.**

Richard Berk. The role of race in forecasts of
violent crime. Race and social problems, 1(4):
231, 2009.**

Alexandra Chouldechova. Fair prediction with
disparate impact: A study of bias in recidivism
prediction instruments. arXiv, 2017.**

Jesse Davis and Mark Goadrich. The relation-
ship between precision-recall and roc curves.
In Proceedings of the 23rd international con-
ference on Machine learning, pages 233‚Äì240.
ACM, 2006.**

J Deng, W Dong, R Socher, L-J Li, K Li, and
L Fei-Fei. ImageNet: A Large-Scale Hierarchi-
cal Image Database. In CVPR09, 2009.**

Cynthia Dwork, Moritz Hardt, Toniann Pitassi,
Omer Reingold, and Richard Zemel. Fairness
through awareness. ITCS, 2011.**

Michael Feldman, Sorelle A Friedler, John
Moeller, Carlos Scheidegger, and Suresh
Venkatasubramanian. Certifying and removing
disparate impact. Proceedings of the 21th ACM
SIGKDD International Conference on Knowl-
edge Discovery and Data Mining, 2015.**

Sorelle A Friedler, Carlos Scheidegger, and
Suresh Venkatasubramanian. On the
(im)possibility of fairness. arXiv preprint
arXiv:1609.07236, 2016.**

Moritz Hardt, Eric Price, and Nathan Srebro.
Equality of opportunity in supervised learning.
NIPS, 2016.**

Avinatan Hassidim, Assaf Romm, and Ran I
Shorrer. Redesigning the israeli psychology
master‚Äôs match. American Economic Review,
107(5):205‚Äì09, May 2017. doi: 10.1257/aer.
p20171048. URL http://www.aeaweb.org/
articles?id=10.1257/aer.p20171048.**

U Hebert-Johnson, M Kim, O Reingold,
and G Rothblum. Calibration for the
(computationally-identifiable) masses. 2017.
arXiv:1711.08513v1.**

Matthew Joseph, Michael Kearns, Jamie H Mor-
genstern, and Aaron Roth. Fairness in learn-
ing: Classic and contextual bandits. In Ad-
vances in Neural Information Processing Sys-
tems, pages 325‚Äì333, 2016.**

Toshihiro Kamishima, Shotaro Akaho, and Jun
Sakuma. Fairness-aware learning through reg-
ularization approach. In Proceedings of the
2011 IEEE 11th International Conference on
Data Mining Workshops, ICDMW ‚Äô11, pages
643‚Äì650, Washington, DC, USA, 2011. IEEE
Computer Society. ISBN 978-0-7695-4409-0.
doi: 10.1109/ICDMW.2011.83. URL http:
//dx.doi.org/10.1109/ICDMW.2011.83.**

Niki Kilbertus, Mateo Rojas-Carulla, Giambat-
tista Parascandolo, Moritz Hardt, Dominik
Janzing, and Bernhard SchoÃàlkopf. Avoiding
discrimination through causal reasoning. arXiv
preprint arXiv:1706.02744, 2017.**

Jon Kleinberg, Sendil Mullainathan, and Man-
ish Raghavan. Inherent trade-offs in the fair
determination of risk scores. arXiv, 2016.**

Alex Krizhevsky, Ilya Sutskever, and Geoffrey E
Hinton. Imagenet classification with deep con-
volutional neural networks. In F. Pereira,
C. J. C. Burges, L. Bottou, and K. Q. Wein-
berger, editors, Advances in Neural Informa-
tion Processing Systems 25, pages 1097‚Äì1105.
Curran Associates, Inc., 2012.**

M J Kusner, J R Loftus, C Russell, and
R Silva. Counterfactual Fairness. ArXiv e-
prints, March 2017.**

Matt J Kusner, Joshua R Loftus, Chris Russell,
and Ricardo Silva. Counterfactual fairness.
arXiv preprint arXiv:1703.06856, 2017.**

Razieh Nabi and Ilya Shpitser. Fair inference on
outcomes. arXiv preprint arXiv:1705.10378,
2017.**

Judea Pearl, Madelyn Glymour, and Nicholas P
Jewell. Causal inference in statistics: a primer.
John Wiley & Sons, 2016.**

Dino Pedreschi, Salvatore Ruggieri, and Franco
Turini. Discrimination-aware data mining. In
Proceedings of the 14th ACM SIGKDD In-
ternational Conference on Knowledge Discov-
ery and Data Mining, KDD ‚Äô08, pages 560‚Äì
568, New York, NY, USA, 2008. ACM. ISBN
978-1-60558-193-4. doi: 10.1145/1401890.
1401959. URL http://doi.acm.org/10.
1145/1401890.1401959.**

R Zemel, Y Wu, K Swersky, T Pitassi, and
C Dwork. Learning fair representations. Proc.
of Intl. Conf. on Machine Learning, 2013.**

Indre Zliobaite, Faisal Kamiran, and Toon
Calders. Handling conditional discrimination.
In Proceedings of the 2011 IEEE 11th Inter-
national Conference on Data Mining, ICDM
‚Äô11, pages 992‚Äì1001, Washington, DC, USA,
2011. IEEE Computer Society. ISBN 978-
0-7695-4408-3. doi: 10.1109/ICDM.2011.
72. URL http://dx.doi.org/10.1109/ICDM.
2011.72.**

Appendix A. Transfer Learning
Bounds
We derive a closed-form solution for Œ∏, the
(approximately) optimal down-weighting of out-
group data for our transfer learning algorithm.
This solution depends on a bound ‚àÜ (defined in
Theorem 8) on the difference in classifier rank-
ing across different groups. For small ‚àÜ, the dif-
ference in error rates of each pair of classifiers
is approximately the same for in-group and out-
group data. In this case, we expect generalization
to work well and hence Œ∏ ‚âà 1. For large ‚àÜ, out-
group data doesn‚Äôt provide much guidance for the
optimal in-group classifier, and we expect Œ∏ ‚âà 0.
Finally, for a fixed k and Œ∏ ‚àà [0, 1], let cÃÇ be a
classifier that minimizes the empirical loss when
out-of-group samples are down-weighted by Œ∏,
i.e.,
cÃÇ ‚àà arg min
c‚ààCkP
nk ÀÜÃÄ
k(c) + Œ∏n‚àík ÀÜÃÄ‚àík(c),
and c‚àó be an optimal classifier that minimizes the
true loss, i.e.,
c‚àó ‚àà arg min
c‚ààCkP
`k(c).
We would like to choose Œ∏ such that `k(cÃÇ) is
close to `k(c‚àó). In order to derive a closed-form
solution for Œ∏ in terms of ‚àÜ, we use concentration
bounds to bound the expected error rates of cÃÇ
and c‚àó in terms of ‚àÜ and Œ∏, and then choose Œ∏ to
minimize this expression.
Lemma 9 Fix any k ‚â§ K,P, nk, n‚àík ‚â• 0
and ‚àÜ, Œ∏ ‚â• 0. Let „Äàxi, yi„Äâni=1 be n = nk +
n‚àík training examples drawn from D conditioned
on exactly nk belonging to group k. Let cÃÇ ‚àà
arg minc‚ààCkP
nk ÀÜÃÄ
k(c) + Œ∏n‚àík ÀÜÃÄ‚àík(c) be any min-
imizer of empirical error when the non-group-k
examples have been down-weighted by Œ∏. Then,
Pr
[
`k(cÃÇ) ‚â§ min
c‚ààCkP
`k(c) + f(Œ∏, nk, n‚àík,‚àÜ, Œ¥)
]
‚â• 1‚àíŒ¥,
where the probability is taken over the n = nk +
n‚àík training iid samples, and f(Œ∏, nk, n‚àík,‚àÜ, Œ¥)
is defined as:
(‚àö
2(nk + Œ∏2n‚àík) log
2|C|
Œ¥
+ Œ∏n‚àík‚àÜ
)
.
(5)
Unfortunately, the minimum value of f is a
complicated algebraic quantity that is easy to
compute but not easy to directly interpret. In-
stead, we can see that:
Lemma 10 For f from Equation (5),
g(nk, n‚àík,‚àÜ, Œ¥) = minŒ∏‚àà[0,1] f(Œ∏, nk, n‚àík,‚àÜ, Œ¥)
is at most
min
Ô£´Ô£≠‚àö 2
nk
log
2|C|
Œ¥
,
‚àö
log
2|C|
Œ¥
+
n‚àík
n
‚àÜ
Ô£∂Ô£∏ ,
(6)
with equality if and only if nk ‚â• 2
‚àÜ2 log 2|C|
Œ¥ in
which case the minimum occurs at Œ∏ = 0 where
g(nk, n‚àík,‚àÜ) =
‚àö
log 2|C|
Œ¥ . Otherwise the
minimum occurs at,
Œ∏‚àó =
‚àö
Œ≤2
n‚àík
nk
(1‚àí Œ≤)‚àí Œ≤
for Œ≤ = ‚àÜ2 2
nk
log(2|C|/Œ¥).
Appendix B. Dataset ids
For reproducibility, the id‚Äôs and feature names
for the 47 open ml datasets were as follows:
(21, ‚Äôbuying‚Äô), (23, ‚ÄôWifes education‚Äô), (26,
‚Äôparents‚Äô), (31, ‚Äôchecking status‚Äô), (50, ‚Äôtop-
left-square‚Äô), (151, ‚Äôday‚Äô), (155, ‚Äôs1‚Äô), (183,
‚ÄôSex‚Äô), (184, ‚Äôwhite king row‚Äô), (292, ‚ÄôY‚Äô),
(333, ‚Äôclass‚Äô), (334, ‚Äôclass‚Äô), (335, ‚Äôclass‚Äô),
(351, ‚ÄôY‚Äô), (354, ‚ÄôY‚Äô), (375, ‚Äôspeaker‚Äô), (469,
‚ÄôDMFT.Begin‚Äô), (475, ‚ÄôTime of survey‚Äô), (679,
‚Äôsleep state‚Äô), (720, ‚ÄôSex‚Äô), (741, ‚Äôsleep state‚Äô),
(825, ‚ÄôRAD‚Äô), (826, ‚ÄôOccasion‚Äô), (872, ‚ÄôRAD‚Äô),
(881, ‚Äôx3‚Äô), (915, ‚ÄôSMOKSTAT‚Äô), (923, ‚Äôisns‚Äô),
(934, ‚Äôfamily structure‚Äô), (959, ‚Äôparents‚Äô), (983,
‚ÄôWifes education‚Äô), (991, ‚Äôbuying‚Äô), (1014,
‚ÄôDMFT.Begin‚Äô), (1169, ‚ÄôAirline‚Äô), (1216, ‚Äôclick‚Äô),
(1217, ‚Äôclick‚Äô), (1218, ‚Äôclick‚Äô), (1235, ‚Äôelevel‚Äô),
(1236, ‚Äôsize‚Äô), (1237, ‚Äôsize‚Äô), (1470, ‚ÄôV2‚Äô), (1481,
‚ÄôV3‚Äô), (1483, ‚ÄôV1‚Äô), (1498, ‚ÄôV5‚Äô), (1557, ‚ÄôV1‚Äô),
(1568, ‚ÄôV1‚Äô), (4135, ‚ÄôRESOURCE‚Äô), (4552, ‚ÄôV1‚Äô)
